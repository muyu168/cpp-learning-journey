1. 信号量（semaphore）
	信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
特点
	信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
	信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。（P操作:拿锁。V操作：放回锁）
	每次对信号量的 PV 操作不仅限于对信号量值加 1 或 减1 ，而且可以加加减任意正整数。
支持信号量组。
2. 函数原型
	最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做二值信号量（Binary Semaphore）。而可以取多个正整数的信号量被称为通用信号量。
	Linux 下的信号量函数都是在通用的信号量数组上进行操作，而不是在一个单一的二值信号量上进行操作。
所包含库
#include<sys/types/h>
#inlcude<sys/ipc.h>
#include<sys/sem.h>

函数原型
//创建或获取一个信号量组，成功会返回信号量集 ID ，失败返回 -1
int semget(key_t key, int nsems, int semflg);
//对信号量组进行操作，改变信号量的值，成功返回 0，失败返回 -1 （用于 PV 操作）
int semop(int semid, struct sembuf *sops, unsigned nsops);    
//控制信号量的相关信息 （用于给信号量初始化）
int semctl(int semid, int semnum, int cmd, ...);

函数说明
int semget(key_t key, int nsems, int semflg);

参数：

key:一个整型值对应内核中一个信号量对象，可以自己指定，不同信号量的key值不一样。不相关的进程可以通过它访问同一个信号量。程序对所有信号量的访问都是间接的，它先提供一个键，再由系统生成一个响应的信号标识符。

nsems:信号集中信号量的个数

semflg: 由九个权限标志构成，它们的用法和创建文件时使⽤的mode模式标志是一样的

返回值：成功返回⼀一个⾮非负整数，即该信号集的标识码；失败返回-1


int semop(int semid, struct sembuf *sops, unsigned nsops);

参数 ：

**semid:**是该信号量的标识码，也就是semget函数的返回值

**sops:**是个指向一个结构数值的指针

指向一个结构数组的指针，每个数组元素至少包含以下几个成员：
 
struct sembuf{
   short sem_num; //信号量编号，除非使用一组信号量，否则它的取值为0
   short sem_op;  //信号量在一次操作中需要改变的数值。通常用到两个值，-1，也就是p操作，表示拿锁；+1，也就是V操作，表示放回锁。
   short sem_flg; //通过被设置为SEM_UNDO。表示操作系统会跟踪当前进程对这个信号量的修改情况，如果这个进程在没有释放该信号量的情况下终止，操作系统将自动释放该进程持有的信号量，防止其他进程一直处于等待状态。 
};  
**nsops:**信号量的个数

返回值：成功返回0；失败返回-1


int semctl(int semid, int semnum, int cmd,...);

系统调用semctl用来执行在信号量集上的控制操作。这和在消息队列中的系统调用msgctl是十分相似的。但这两个系统调用的参数略有不同。

semid： 信号量的标志码(ID)，也就是semget（）函数的返回值;

semnum： 操作信号在信号集中的编号。从0开始。

cmd： 命令，表示将要进行的操作。

参数cmd中可以使用的命令如下：

·IPC_STAT 读取一个信号量集的数据结构semid_ds，并将其存储在semun中的buf参数中。
·IPC_SET 设置信号量集的数据结构semid_ds中的元素ipc_perm，其值取自semun中的buf参数。
·IPC_RMID 将信号量集从内存中删除。
·GETALL 用于读取信号量集中的所有信号量的值。
·GETNCNT 返回正在等待资源的进程数目。
·GETPID 返回最后一个执行semop操作的进程的PID。
·GETVAL 返回信号量集中的一个单个的信号量的值。
·GETZCNT 返回正在等待完全空闲的资源的进程数目。
·SETALL 设置信号量集中的所有的信号量的值。
·SETVAL 设置信号量集中的一个单独的信号量的值。【一般用这个】

此函数具有三个或四个参数，具体取决于cmd。当
有四个时，第四个具有union semun类型。
第四个参数：可选。是否使用取决于所请求的命令。如果使用该参数，则其类型是semun。
union semun{
　　int val；                   SETVAL的值
　　struct semid_ds *buf;       IPC_STAT，IPC_SET的缓冲区 
　　unsigned short *array;      GETALL，SETALL的数组
    struct seminfo __buf;       IPC_INFO的缓冲区（特定于Linux）
};
一般只使用val这个成员，来为信号量赋初值。当信号量值为0时，进程会阻塞运行
val值用于设置信号量的初始计数器值，它决定了信号量的初始状态：

val = 1：资源可用，第一个进程可以立即获取

val = 0：资源被占用，进程需要等待

val = N：有N个资源可用


/*对于第一次接触这些参数繁多的函数，我想大多数人都会学的云里雾里的，这里我使用c++函数重载的理念来解释复杂参数的设计理念
我们知道c++当中一个函数名可以在修改不同参数来做到函数重载，这使得一个功能函数的接口同一，减少了代码的冗余，而c语言中并没有这样函数重载的功能，那么对于c语言来说，怎么做到这种类函数重载的功能呢，这就呈现出了Unix/Linux系统调用的巧妙设计，通过参数结构体和命令字来模拟，实现伪函数重载
看到这或许我们还会存在很多疑惑，设计成这样复杂的参数不是会更难用吗，让我们换个思路去想，如果我们想要实现一些类似的功能，有函数重载的话，我们就只需要记住一个函数名，而不用记住繁索的多个函数名，而c中没有函数重载，我们又不想记住那么多函数名，该怎么实现这个功能呢，我们可以发现，函数重载的本质也就是类似不同参数之间不影响函数的调用，并且可以实现不同功能，那么我们可以使用一些命令字来告诉函数我们这次调用想要实现什么功能，然后使用参数结构体存储所有功能可能使用的参数，通过这样的设计，我们就可以成功实现伪函数重载，其中参数结构体中的参数在命令字指定的功能不使用时，对函数功能没有任何影响，这样我们可以自主的使用同一个函数名来使用不同的功能*/

为什么这种设计很优秀？
1. 接口统一性
只需记住semctl一个函数名，而不是sem_setval、sem_getval、sem_delete等多个函数名。

2. 扩展性强
添加新功能只需：

定义新的命令字

在联合体中添加对应的参数成员

不影响现有代码的兼容性

3. 系统资源节约
减少系统调用号的使用，内核中只需维护较少的系统调用入口。

4. 错误处理统一
所有相关操作共享相同的错误处理机制。

想象这样的函数就是一个"万能遥控器"：

命令字：相当于按下"开机"、"调音量"、"换台"等按钮

参数结构体：相当于遥控器上所有的按钮和旋钮

按需使用：调音量时只用音量按钮，换台时只用频道按钮，其他按钮被忽略
