# 高效复盘方法指南

## 🎯 复盘的核心目标

**从"会搭建"到"真正理解"再到"能独立设计"**

复盘不是简单地回顾代码，而是要回答三个问题：
1. **做了什么？**（What）
2. **为什么这样做？**（Why）
3. **如何做得更好？**（How）

---

## 📋 复盘的五步法

### 第一步：画图（30分钟）

**目标**：用图形化方式理解整个系统

#### 1.1 架构图
- 画出各个模块之间的关系
- 标注数据流向
- 可以用 ASCII art、流程图工具（如 draw.io）或手绘

**检查标准**：
- ✅ 能不看代码，只看图就理解系统结构
- ✅ 能向别人解释清楚每个模块的作用

#### 1.2 时序图
- 画一次 HTTP 请求的完整流程
- 从客户端发送请求到收到响应
- 标注每个步骤在哪个线程、哪个函数

**检查标准**：
- ✅ 能清晰看到数据在系统中的流转路径
- ✅ 能指出哪些操作是并发的，哪些是串行的

#### 1.3 状态转换图
- 画出 HTTP 解析的状态机
- 标注状态转换的条件

---

### 第二步：代码走读（1-2小时）

**目标**：理解每一行代码的作用和设计意图

#### 2.1 按模块走读
对每个文件，回答这些问题：

**main.cpp**：
- [ ] 为什么用 `users[connfd]` 而不是 `map<int, http_conn>`？
- [ ] 为什么 listenfd 不用 EPOLLONESHOT？
- [ ] 为什么 EPOLLIN 时调用 read() 后立即 append 到线程池？
- [ ] 事件循环中，各种事件的处理顺序为什么是这样？

**http_conn.cpp**：
- [ ] 为什么需要主从状态机？
- [ ] `m_read_idx` 和 `m_checked_index` 的区别是什么？
- [ ] 为什么用 `mmap()` 而不是 `read()`？
- [ ] `writev()` 的两个缓冲区分别是什么？

**threadpool.h**：
- [ ] 为什么用信号量而不是条件变量？
- [ ] `append()` 时为什么先 unlock 再 post？
- [ ] 线程池大小为什么默认是 8？

**locker.h**：
- [ ] 为什么封装而不是直接用 pthread API？

#### 2.2 关键函数深度理解
对关键函数，画出执行流程图：

**http_conn::process_read()**：
```
开始
  │
  ▼
parse_line() 解析一行
  │
  ├─ LINE_OPEN → 继续读取
  ├─ LINE_BAD → 返回 BAD_REQUEST
  └─ LINE_OK → 继续
      │
      ▼
根据 m_check_state 选择解析函数
  │
  ├─ REQUESTLINE → parse_request_line()
  ├─ HEADER → parse_headers()
  └─ CONTENT → parse_content()
      │
      ▼
返回解析结果
```

---

### 第三步：技术点深挖（2-3小时）

**目标**：理解每个技术点的原理和为什么用它

#### 3.1 制作技术点卡片

对每个关键技术点，制作一张"知识卡片"：

**卡片模板**：
```
技术点：epoll 边缘触发（ET）
├─ 是什么：只在文件描述符状态变化时触发一次事件
├─ 为什么用：减少 epoll_wait 调用次数，提高性能
├─ 怎么用：配合非阻塞 IO，循环读取直到 EAGAIN
├─ 注意事项：必须一次性读取完所有数据
└─ 对比：LT 模式会持续触发，ET 模式只在变化时触发
```

**需要制作卡片的技术点**：
- [ ] epoll vs select/poll
- [ ] ET vs LT 模式
- [ ] EPOLLONESHOT
- [ ] 非阻塞 IO
- [ ] 线程池模型
- [ ] 状态机解析
- [ ] mmap 零拷贝
- [ ] writev 分散写
- [ ] 互斥锁 vs 信号量

#### 3.2 对比学习

**对比不同实现方式**：
- 阻塞 IO vs 非阻塞 IO
- 多线程阻塞 vs 单线程事件驱动
- select vs epoll
- 传统 read/write vs mmap/writev

**思考**：为什么在这个场景下选择这种方式？

---

### 第四步：问题发现与改进（1小时）

**目标**：找出代码中的问题和改进空间

#### 4.1 代码审查清单

**功能问题**：
- [ ] 硬编码的配置（如 doc_root）
- [ ] 错误处理不完善
- [ ] 边界条件未处理

**性能问题**：
- [ ] 是否有不必要的拷贝？
- [ ] 是否有锁竞争？
- [ ] 是否有内存泄漏？

**设计问题**：
- [ ] 模块职责是否清晰？
- [ ] 是否便于扩展？
- [ ] 是否便于测试？

#### 4.2 改进方案

对每个问题，写出：
- **问题描述**：具体是什么问题
- **影响**：这个问题会导致什么后果
- **改进方案**：如何改进（可以写伪代码）

---

### 第五步：知识体系化（1小时）

**目标**：把零散的知识点串联成体系

#### 5.1 制作知识地图

```
高性能服务器设计
├─ I/O 模型
│   ├─ 阻塞 IO
│   ├─ 非阻塞 IO
│   ├─ IO 多路复用（select/poll/epoll）
│   └─ 异步 IO
│
├─ 并发模型
│   ├─ 多进程
│   ├─ 多线程
│   ├─ 线程池
│   └─ 协程
│
├─ 协议解析
│   ├─ HTTP 协议
│   ├─ 状态机设计
│   └─ 流式解析
│
└─ 性能优化
    ├─ 零拷贝
    ├─ 内存池
    └─ 缓存策略
```

#### 5.2 建立知识关联

**问自己**：
- 这个项目用到了知识地图中的哪些点？
- 哪些点还没用到？为什么？
- 如果要扩展功能，需要用到哪些新知识？

---

## 🎯 复盘检查清单

### 理解层面
- [ ] 我能不看代码，画出完整的架构图
- [ ] 我能解释每个模块的职责
- [ ] 我能说明一次请求的完整流程
- [ ] 我能解释每个技术选择的理由

### 代码层面
- [ ] 我能不看教程，独立写出 main.cpp 的核心逻辑
- [ ] 我能独立实现一个简单的 HTTP 解析函数
- [ ] 我能独立实现一个简单的线程池

### 改进层面
- [ ] 我能指出代码中的潜在问题
- [ ] 我能提出至少 3 个改进方向
- [ ] 我能独立实现至少 1 个改进

---

## 💡 复盘技巧

### 1. 费曼学习法
**向别人解释**：假设你要向一个不懂的人解释这个项目
- 如果解释不清楚，说明你还没真正理解
- 解释的过程会暴露你的知识盲点

### 2. 对比学习法
**对比不同实现**：
- 对比你的实现和 Nginx/muduo 的实现
- 对比不同的技术选择（如 select vs epoll）
- 找出差异和原因

### 3. 问题驱动法
**不断问为什么**：
- 为什么用 epoll 不用 select？
- 为什么用 ET 不用 LT？
- 为什么用线程池不用多进程？
- 每个"为什么"都要有明确的答案

### 4. 实践验证法
**动手验证理解**：
- 修改代码，看会发生什么
- 删除某个功能，看系统是否还能工作
- 添加日志，观察实际执行流程

---

## 📅 复盘时间安排建议

### 第一次复盘（完成项目后立即）
- **时间**：3-4 小时
- **重点**：画图 + 代码走读
- **产出**：架构图、时序图、关键问题清单

### 第二次复盘（1周后）
- **时间**：2-3 小时
- **重点**：技术点深挖 + 问题改进
- **产出**：技术点卡片、改进方案

### 第三次复盘（1个月后）
- **时间**：1-2 小时
- **重点**：知识体系化 + 对比学习
- **产出**：知识地图、对比分析

---

## 🚀 开始你的第一次复盘

1. **打开 `复盘文档.md`**，按照模板填写
2. **画架构图**：可以用 ASCII art 或工具
3. **代码走读**：逐个模块，回答"为什么"的问题
4. **记录问题**：把不理解的地方记录下来
5. **查找资料**：针对问题查找资料，完善理解

**记住**：复盘不是一次性的，而是一个持续的过程。每次复盘都会有新的收获！
